{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/ADMM.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\nimport {IPortalToken} from \"./interfaces/IPortalToken.sol\";\nimport {IUniswapPool} from \"./interfaces/IUniswapPool.sol\";\nimport \"./uniswap/core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"./interfaces/IUniswapPositionManager.sol\";\nimport \"./interfaces/IUniswapRouter.sol\";\nimport \"./interfaces/IPoolManager.sol\";\nimport \"./interfaces/IAssetManagement.sol\";\nimport {IAsset} from \"./interfaces/IAsset.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\nimport \"./uniswap/core/contracts/libraries/TickMath.sol\";\nimport {IADMM} from \"./interfaces/IADMM.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title  ADMM Contract\n * @dev Contract which manages the swap Process and liquidity accounting and management\n */\ncontract ADMM is IADMM {\n    /**\n     * @notice address of the portal Token contract\n     */\n    IPortalToken public tokenContract;\n\n    /**\n     * @notice address of the pool manager contract\n     */\n    IPoolManager public poolManager;\n\n    /**\n     * @notice address of the asset manager contract\n     */\n    IAssetManagement public assetManager;\n\n    /**\n     * @notice address of the liquidity pool contract\n     */\n    ILiquidityPool public liquidityPool;\n\n    /**\n     * @notice MULTIPLIER of all accounting assets\n     */\n    uint256 public constant MULTIPLIER = 1e18;\n\n    uint256 public priceBTCtoETH = 29;\n\n    using Strings for uint256;\n\n    /**\n     * @notice Custom onlyOwner modifier that checks ownership against the tokenContract's owner\n     */\n    modifier onlyOwner() {\n        require(\n            tokenContract.owner() == msg.sender,\n            \"Caller is not the token contract owner\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Constructor to initialize the management contract\n     * @param _tokenAddress address of the portal token contract\n     * @param _assetManager address of the asset manager contract\n     * @param _liquidityPool address of the liquidity pool contract\n     */\n    constructor(address _tokenAddress, address _assetManager, address _liquidityPool) {\n        tokenContract = IPortalToken(_tokenAddress);\n        assetManager = IAssetManagement(_assetManager);\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @notice set the address of pool manager contract and admin to the factory\n     * @param _poolManager address of the pool manager contract\n     */\n    function setPoolManager(address _poolManager) external onlyOwner {\n        poolManager = IPoolManager(_poolManager);\n        poolManager.factory().addAdmin(_poolManager);\n    }\n\n    /**\n     * @notice Struct to store mapping of all active swaps by id of the swap\n     */\n    mapping(bytes32 => Swap) public swaps;\n\n    /**\n     * @notice Struct to store mapping of all active event outputs of the swap by secretHash\n     */\n    mapping(bytes32 => EventOutput) public eventOutputs;\n\n    /**\n     * @notice Struct to store mapping of all active liquidityPoolId to liquidity of that liquidityPoolId\n     */\n    mapping(bytes32 => Liquidity[]) public liquidities;\n\n    /**\n     * @notice Struct to store mapping of all active liquidity limits with sellAsset and liquidityOwner\n     */\n    mapping(address => mapping(address => LiquidityLimit))\n        public liquidityLimits;\n\n    /**\n     * @notice Struct to store mapping of all active matched liquidities with id\n     */\n    mapping(bytes32 => uint[]) public liquidityIds;\n\n    /**\n     * @notice set the liquidity limit for given owner and the asset\n     * @param liquidityLimit liquidity limit details\n     */\n    function setLiquidityLimit(\n        LiquidityLimit calldata liquidityLimit\n    ) public onlyOwner {\n        // Update the liquidity limit for the given pair and liquidity owner\n        liquidityLimits[liquidityLimit.sellAsset][liquidityLimit.liquidityOwner] = liquidityLimit;\n\n        // Emit an event upon successful update of the liquidity limit\n        emit LiquidityLimitUpdated(liquidityLimit);\n    }\n\n    /**\n     * @notice Liquidity Provider's liquidity committed for a concentrated position for a particular pool\n     * @param liquidity liquidity position details\n     */\n    function commitLiquidity(Liquidity calldata liquidity) public {\n        require(\n            msg.sender == tokenContract.owner() ||\n                msg.sender == liquidity.owner,\n            \"Caller is not the owner or the liquidity owner\"\n        );\n        require(\n            liquidityLimits[liquidity.sellAsset][liquidity.owner]\n                .sellAmount >= liquidity.sellAmount,\n            \"Breached Liquidity Limit\"\n        );\n\n        bytes32 liquidityPoolId = liquidityPool.retrievePoolId(\n            liquidity.sellAsset,\n            liquidity.buyAsset,\n            liquidity.poolFee\n        );\n        require(liquidityPoolId != bytes32(0), \"Asset pair not registered\");\n\n        uint insertIndex = _findInsertIndex(liquidityPoolId, liquidity.buyRangeLowLimit);\n\n        _insertLiquidity(liquidityPoolId, insertIndex, liquidity);\n        // _updatePool(\n        //     liquidity.sellAsset,\n        //     liquidity.buyAsset,\n        //     liquidity.poolFee,\n        //     liquidity.sellAmount\n        // );\n        liquidityLimits[liquidity.sellAsset][liquidity.owner]\n            .sellAmount -= liquidity.sellAmount;\n        emit LiquidityCommitted(liquidity);\n    }\n\n    /**\n     * @dev internal helper function to find insert index for a liquidity position\n     * @param liquidityPoolId  liquidityPoolId of the pool\n     * @param buyRangeLowLimit sorted by liquidity position's buy low limit\n     */\n    function _findInsertIndex(\n        bytes32 liquidityPoolId,\n        uint buyRangeLowLimit\n    ) internal view returns (uint) {\n        uint length = liquidities[liquidityPoolId].length;\n        for (uint i = 0; i < length; i++) {\n            if (buyRangeLowLimit < liquidities[liquidityPoolId][i].buyRangeLowLimit) {\n                return i;\n            }\n        }\n        return length;\n    }\n\n    /**\n     * @dev internal helper function to insert liquidity position\n     * @param liquidityPoolId  liquidityPoolId of the pool\n     * @param insertIndex index to insert the liquidity position\n     * @param newLiquidity liquidity position to be inserted\n     */\n    function _insertLiquidity(\n        bytes32 liquidityPoolId,\n        uint insertIndex,\n        Liquidity memory newLiquidity\n    ) internal {\n        liquidities[liquidityPoolId].push();\n        uint length = liquidities[liquidityPoolId].length;\n        if (length > 1) {\n            for (uint i = length - 1; i > insertIndex; i--) {\n                liquidities[liquidityPoolId][i] = liquidities[liquidityPoolId][i - 1];\n            }\n        }\n        liquidities[liquidityPoolId][insertIndex] = newLiquidity;\n    }\n\n    /**\n     * @notice function to update the pool or create a pool when pool doesn't exist\n     * @param sellAsset Liquidity Provider's Sell asset address\n     * @param buyAsset Liquidity Provider's Buy asset address\n     * @param poolFee Fee of the pool\n     * @param sellAmount Amount Liquidity Provider providing liquidity for\n     */\n    function _updatePool(\n        address sellAsset,\n        address buyAsset,\n        uint poolFee,\n        uint sellAmount\n    ) internal {\n        address pool = poolManager.getPool(\n            sellAsset,\n            buyAsset,\n            uint24(poolFee)\n        );\n        if (pool == address(0)) {\n            poolManager.createPool(buyAsset, sellAsset, 0);\n        }\n        uint160 sqrtPriceX96 = poolManager.getPoolPrice(\n            buyAsset,\n            sellAsset,\n            0\n        );\n        uint price = sqrtPriceX96ToPrice(sqrtPriceX96);\n        uint256 buyAmount = sellAmount * price;\n        int24 tickLower = TickMath.getMinTick(10);\n        int24 tickUpper = TickMath.getMaxTick(10);\n\n        // Added sorting mechanism to ensure passing sorted token addresses to position manager of uniswap contract\n        // Additional parameters associated with the token address should also be sorted\n        // e.g if sellAsset address is < than buyAsset address, then sellAmount as well as sellNetworkId\n        // and any other parameters should also be swaped with buy parameters.\n        // In this case, if amountMin wasn't 0 for both asset, it should also be swaped\n        // This is to ensure that the position manager contract of uniswap receives the parameters in the correct swap\n        // This needs to be implemented for the other positionManager calls as well such as increaseLiquidity, decreaseLiquidity, etc.\n        if (sellAsset > buyAsset) {\n            address tmp = sellAsset;\n            sellAsset = buyAsset;\n            buyAsset = tmp;\n\n            uint256 tmpAmount = sellAmount;\n            sellAmount = buyAmount;\n            buyAmount = tmpAmount;\n        }\n        poolManager.createPosition(\n            IPoolManager.LpToken({\n                addr: sellAsset,\n                amountDesired: sellAmount,\n                amountMin: 0\n            }),\n            IPoolManager.LpToken({\n                addr: buyAsset,\n                amountDesired: buyAmount,\n                amountMin: 0\n            }),\n            address(this),\n            0,\n            block.timestamp + 60,\n            tickLower,\n            tickUpper\n        );\n    }\n\n    /**\n     * @notice function to remove liquidity from the pool\n     * @param liquidityId liquidity position id referring to the index of the position\n     * @param liquidityPoolId unique identifier of the liquidity pool\n     */\n    function removeLiquidity(\n        uint liquidityId,\n        bytes32 liquidityPoolId\n    )\n        public\n    {\n        require(liquidityPoolId != bytes32(0), \"Asset pair not registered\");\n        require(\n            liquidityId < liquidities[liquidityPoolId].length,\n            \"Invalid liquidityId\"\n        );\n\n        // Store the liquidity to be removed for event emission\n        Liquidity memory liq = liquidities[liquidityPoolId][liquidityId];\n        require(\n            msg.sender == tokenContract.owner() || msg.sender == liq.owner,\n            \"Caller is not the owner or the liquidity owner\"\n        );\n\n        // Shift elements to the left to fill the gap created by the removed liquidity\n        for (uint i = liquidityId; i < liquidities[liquidityPoolId].length - 1; i++) {\n            liquidities[liquidityPoolId][i] = liquidities[liquidityPoolId][i + 1];\n        }\n        // Remove the last element after shifting\n        liquidities[liquidityPoolId].pop();\n        // // TODO: Remove liquidity from UniswapV3\n        // poolManager.decreaseLiquidity(\n        //     msg.sender,\n        //     liq.sellAmount,\n        //     liq.sellAmount, // TODO: why are this same?\n        //     0\n        // );\n\n        liquidityLimits[liq.sellAsset][liq.owner].sellAmount += liq.sellAmount;\n\n        // Emit the event after the liquidity has been successfully removed\n        emit LiquidityRemoved(liq);\n    }\n\n    /**\n     * @notice function to register a swap in Portal Chain\n     * @param swap details of the swap\n     */\n    function createSwap(\n        Swap memory swap\n    ) public {\n        swap.swapCreation = block.timestamp;\n        swap.status = \"created\";\n        // Record a new swap with provided parameters\n        swaps[swap.id] = swap;\n        // Emit an event upon successful recording of the swap\n        emit SwapCreated(swap);\n    }\n\n    /**\n     * @notice function to validate a swap\n     * @param id unique id of the swap\n     */\n    function validateSwap(bytes32 id) public onlyOwner {\n        Swap storage swap = swaps[id];\n        require(keccak256(abi.encodePacked(swap.status)) == keccak256(abi.encodePacked(\"created\")), \"Swap is not in created state\");\n        swap.status = \"validated\";\n        emit SwapValidated(swap);\n    }\n\n    /**\n     * @notice function to register lightning invoice in Portal Chain\n     * @param invoice lightning Invoice details for the swap\n     */\n    function registerInvoice(Invoice calldata invoice) public {\n        Swap storage swap = swaps[invoice.id];\n        EventOutput storage eventOutput = eventOutputs[swap.secretHash];\n        require(keccak256(abi.encodePacked(swap.status)) == keccak256(abi.encodePacked(\"matched\")), \"Swap is not in matched state\");\n        swap.status = \"invoiceRegistered\";\n        swap.secretHash = invoice.secretHash;\n        eventOutput.secretHash = invoice.secretHash;\n        eventOutput.invoice = invoice.invoice;\n        eventOutputs[invoice.secretHash] = eventOutput;\n        emit InvoiceRegistered(invoice);\n    }\n\n    // TODOO; bookkeeping of pay and settle invoice\n\n    /**\n     * @notice internal function to select a random number among all numbers from 0 to n\n     * @param n Upper limit of the random number\n     */\n    function random(uint n) internal view returns (uint) {\n        // Combine the hash of the most recently completed block with the current block's difficulty\n        uint randomHash = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.prevrandao)\n            )\n        );\n        // Generate a random number using 'n'\n        return randomHash % n;\n    }\n\n    /**\n     * @notice function to match a swap with a liquidity position\n     * @param id Unique Id for the swap\n     */\n    function matchSwap(bytes32 id) public {\n        Swap storage swap = swaps[id];\n        require(keccak256(abi.encodePacked(swap.status)) == keccak256(abi.encodePacked(\"validated\")), \"Swap is not in validated state\");\n        swap.status = \"matched\";\n        bytes32 liquidityPoolId = swap.liquidityPoolId;\n        // TODO: Ensure reflects  in UniswapV3 396,404.\n        // uint buyAmount = poolManager.exactInputSingle(\n        //     swap.sellAsset,\n        //     swap.buyAsset,\n        //     0,\n        //     swap.sellAmount\n        // );\n\n        IAsset.AssetData memory sellAssetData = assetManager.retrieveAsset(swap.sellAsset);\n\n        uint buyAmount;\n        if (keccak256(abi.encodePacked(sellAssetData.symbol)) == keccak256(abi.encodePacked(\"BTC\"))) {\n            buyAmount = swap.sellAmount * priceBTCtoETH * 1e10;\n        } else {\n            buyAmount = swap.sellAmount/(priceBTCtoETH * 1e10);\n        }\n        uint price = (buyAmount * MULTIPLIER) / swap.sellAmount;\n        // require(false, string(abi.encodePacked(\"Price:\", price.toString())));\n        uint liquidityId;\n        for (\n            liquidityId = 0;\n            liquidityId < liquidities[liquidityPoolId].length;\n            liquidityId++\n        ) {\n            Liquidity storage liq = liquidities[liquidityPoolId][liquidityId];\n            // Basic criteria for matching: sell and buy assets match and amounts are sufficient\n            if (\n                liq.sellAsset == swap.buyAsset &&\n                liq.buyAsset == swap.sellAsset // &&\n                // buyAmount  <= swap.buyAmount + swap.slippage &&\n                // (price >= liq.buyRangeLowLimit * MULTIPLIER &&\n                //     price <= liq.buyRangeHighLimit * MULTIPLIER)\n            ) {\n                // Simplified match criteria, adjust as needed\n                // Match found, update liquidity and emit event\n                if (liq.sellAmount >= buyAmount) {\n                    liquidityIds[id].push(liquidityId);\n                }\n            }\n        }\n        if (liquidityIds[id].length > 0) {\n            liquidityId = random(liquidityIds[id].length);\n            Liquidity storage liq = liquidities[liquidityPoolId][liquidityId];\n            liq.sellAmount -= buyAmount;\n            eventOutputs[swap.secretHash] = EventOutput(\n                                                id,\n                                                swap.secretHash,\n                                                liq.owner,\n                                                swap.sellAmount,\n                                                buyAmount,\n                                                \"12345\"\n                                            );\n            emit SwapMatched(\n                id,\n                liq.owner,\n                swap.sellAsset,\n                swap.sellAmount,\n                buyAmount\n            );\n        } else {\n            for (\n                liquidityId = 0;\n                liquidityId < liquidities[liquidityPoolId].length;\n                liquidityId++\n            ) {\n                Liquidity storage liq = liquidities[liquidityPoolId][liquidityId];\n\n                // Basic criteria for matching: sell and buy assets match and amounts are sufficient\n                if (\n                    liq.sellAsset == swap.buyAsset &&\n                    liq.buyAsset == swap.sellAsset &&\n                    buyAmount <= swap.buyAmount + swap.slippage &&\n                    liq.sellAmount < buyAmount &&\n                    (price > liq.buyRangeLowLimit * MULTIPLIER &&\n                        price < liq.buyRangeHighLimit * MULTIPLIER)\n                ) {\n                    uint partialMatchedAmount = liq.sellAmount;\n                    liq.sellAmount = 0;\n                    eventOutputs[swap.secretHash] = EventOutput(\n                                    id,\n                                    swap.secretHash,\n                                    liq.owner,\n                                    (liq.sellAmount * MULTIPLIER) / price,\n                                    partialMatchedAmount,\n                                    \"12345\"\n                                );\n                    emit SwapMatched(\n                        id,\n                        liq.owner,\n                        swap.sellAsset,\n                        (liq.sellAmount * MULTIPLIER) / price,\n                        partialMatchedAmount\n                    );\n                    swaps[id].sellAmount -=\n                        (liq.sellAmount * MULTIPLIER) /\n                        price;\n                }\n            }\n        }\n        delete liquidityIds[id];\n    }\n\n    /**\n     * @notice function to retrieve current price of the pool\n     * @param sqrtPriceX96 initial price of the pool\n     */\n    function sqrtPriceX96ToPrice(\n        uint160 sqrtPriceX96\n    ) public pure returns (uint256 price) {\n        // First, convert sqrtPriceX96 to a full-precision number by squaring it.\n        // Note: The squaring of the sqrtPriceX96 value increases its precision to 192 bits,\n        // so it's important to handle this operation carefully to avoid overflow.\n        // Since Solidity doesn't support fixed-point numbers directly, we use uint256 for high precision arithmetic.\n        uint256 numerator = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);\n\n        // Next, adjust for the 96*2 bits of precision from the squaring operation above\n        // by dividing by 2^192, which is equivalent to (2^96)^2.\n        // We represent 2^192 as a combination of two 2^96 factors for simplicity and to fit Solidity's uint256.\n        uint256 denominator = 1 << 192;\n\n        // Calculate the price ratio. The division here is safe since the denominator is non-zero.\n        // This results in a price ratio represented in a fixed-point format with 96 bits of precision.\n        price = numerator / denominator;\n        return price;\n    }\n\n    /**\n     * @notice function to set the price of BTC in terms of ETH\n     * @param price price of the asset\n     */\n    function setPriceBTCtoETH(uint price) public onlyOwner {\n        priceBTCtoETH = price;\n    }\n\n    /**\n     * @notice function to set initial sqrt price of the pool\n     * @param sellAsset Liquidity Provider's Sell asset address\n     * @param buyAsset Liquidity Provider's Buy asset address\n     * @param poolFee Fee of the trading pool\n     * @param initialSqrtPriceX96ToPrice initial price of the pool\n     */\n    function setInitialSqrtPrice(\n        address sellAsset,\n        address buyAsset,\n        uint24 poolFee,\n        uint160 initialSqrtPriceX96ToPrice\n    )\n        external\n        onlyOwner\n    {\n        poolManager.setInitialSqrtPrice(\n            sellAsset,\n            buyAsset,\n            poolFee,\n            initialSqrtPriceX96ToPrice\n        );\n    }\n}\n"
    },
    "contracts/Asset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\nimport {IAsset} from \"./interfaces/IAsset.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Asset\n * The Asset contract represents an asset with specific attributes and\n * restrictions. It inherits from the ERC20 standard and includes additional\n * metadata for asset management.\n *\n * An asset is a representation of a tradable token on the portal chain, and\n * is modeled similar to an ERC-20 token, with additional metadata, namely:\n * - The name of the native blockchain.\n * - The chain-id of the native blockchain, relevant only for EVM chains.\n * - The address of the ERC20 contract asset on the native blockchain.\n * - The number of decimals used by the asset on its native blockchain.\n * - The logo of the asset as a SVG string.\n */\ncontract Asset is IAsset, ERC20 {\n    AssetData private asset;\n\n    /**\n     * Initializes the contract setting the Asset Details\n     * @param _asset Properties of the asset\n     */\n    constructor(\n        IAsset.AssetData memory _asset\n    ) ERC20(_asset.name, _asset.symbol) {\n        asset = AssetData({\n            id: address(this),\n            name: _asset.name,\n            symbol: _asset.symbol,\n            logo: _asset.logo,\n            blockchainId: _asset.blockchainId,\n            blockchainName: _asset.blockchainName,\n            blockchainAddress: _asset.blockchainAddress,\n            blockchainDecimals: _asset.blockchainDecimals\n        });\n    }\n\n    /**\n     * Returns the address of the asset on the portal blockchain\n     */\n    function id() public view returns (address) {\n        return asset.id;\n    }\n\n    /**\n     * Returns the decimals used by the asset on its native blockchain\n     */\n    function decimals() public view override returns (uint8) {\n        return asset.blockchainDecimals;\n    }\n\n    /**\n     * Returns all the properties of the asset. This is primarily used to return\n     * data in JSON format to the JavaScript layer.\n     */\n    function toAssetData() public view returns (AssetData memory) {\n        return asset;\n    }\n}\n"
    },
    "contracts/interfaces/IADMM.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\n/**\n * @title IADMM\n * @notice Interface for the ADMM contract\n */\ninterface IADMM {\n    /**\n     * @dev Data Structure of LiquidityLimit position\n     * @param liquidityOwner Address of the liquidity owner\n     * @param sellAsset Liquidity Provider's Sell asset address\n     * @param sellAmount Amount Liquidity Provider providing liquidity for\n     */\n    struct LiquidityLimit {\n        address liquidityOwner;\n        address sellAsset;\n        uint sellAmount;\n    }\n\n    /**\n     * @dev Event emitted when liquidity position is updated\n     * @param liquidityLimit LiquidityLimit details\n     */\n    event LiquidityLimitUpdated(LiquidityLimit liquidityLimit);\n\n    /**\n     * @dev Data Structure of Liquidity position\n     * @param owner Address of the liquidity owner\n     * @param sellAsset Address of the asset to be sold\n     * @param sellAmount Amount of the asset to be sold\n     * @param buyAsset Address of the asset to be bought\n     * @param poolFee Pool fee percentage\n     * @param buyRangeLowLimit Lower limit of the buy range\n     * @param buyRangeHighLimit Upper limit of the buy range\n     */\n    struct Liquidity {\n        address owner;\n        address sellAsset;\n        uint sellAmount;\n        address buyAsset;\n        uint poolFee;\n        uint buyRangeLowLimit;\n        uint buyRangeHighLimit;\n    }\n\n    /**\n     * @dev Event emitted when liquidity position is committed for a particular pool\n     * @param liquidity Liquidity position to be committed\n     */\n    event LiquidityCommitted(Liquidity liquidity);\n\n    /**\n     * @dev Event emitted when liquidity position is removed\n     * @param liquidity Liquidity position to be committed\n     */\n    event LiquidityRemoved(Liquidity liquidity);\n\n    /**\n     * @dev Data Structure of swap Swap\n     * @param id Unique identifier of the swap\n     * @param liquidityPoolId Unique identifier of the pair\n     * @param secretHash Hash of the secret\n     * @param sellAsset Address of the asset to be sold\n     * @param sellAmount Amount of the asset to be sold\n     * @param buyAsset Address of the asset to be bought\n     * @param buyAmount Amount of the asset to be bought\n     * @param slippage Slippage percentage in bps\n     * @param swapCreation Timestamp of the swap creation\n     * @param swapOwner Address of the swap owner\n     * @param buyId Unique identifier of the trader in counterparty chain\n     * @param status Status of the swap\n     */\n    struct Swap {\n        bytes32 id;\n        bytes32 liquidityPoolId;\n        bytes32 secretHash;\n        address sellAsset;\n        uint sellAmount;\n        address buyAsset;\n        uint buyAmount;\n        uint slippage;\n        uint swapCreation;\n        address swapOwner; \n        string buyId;\n        string status;       \n    }\n\n    struct EventOutput {\n        bytes32 id;\n        bytes32 secretHash;\n        address matchedLp;\n        uint matchedSellAmount;\n        uint matchedBuyAmount;\n        string invoice;\n    }\n\n\n    /**\n     * @dev Event emitted when a swap is registered\n     * @param swap swap details\n     */\n    event SwapCreated(Swap swap);\n\n    /**\n     * @dev Event emitted when a swap is registered\n     * @param swap swap details\n     */\n    event SwapValidated(Swap swap);\n\n    /**\n     * @dev Event emitted when a swap is matched\n     * @param id Unique identifier of the swap\n     * @param liquidityOwner Address of the liquidity owner\n     * @param sellAsset asset address to be sold\n     * @param matchedSellAmount Matched amount of the asset to be sold\n     * @param matchedBuyAmount Matched amount of the asset to be bought\n     */\n    event SwapMatched(\n        bytes32 indexed id,\n        address indexed liquidityOwner,\n        address sellAsset,\n        uint matchedSellAmount,\n        uint matchedBuyAmount\n    );\n\n    /**\n     * @dev Data Structure of Invoice\n     * @param id Unique identifier of the swap\n     * @param secretHash Hash of the secret\n     * @param invoice Invoice of the swap\n     */\n    struct Invoice {\n        bytes32 id;\n        bytes32 secretHash;\n        uint amount;\n        string invoice;\n    }\n\n    /**\n     * @dev Event emitted when an invoice is successfully registered\n     * @param invoice invoice of the swap which is registered on portal chain\n     */\n    event InvoiceRegistered(Invoice invoice);\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\n/**\n * @title IAsset\n * Interface for the Asset contract that defines all tradable assets in the\n * Portal ecosystem.\n */\ninterface IAsset {\n    /**\n     * Stores the particulars of an asset.\n     * @param id Address of the asset on the portal chain\n     * @param name Human-readable name of the asset\n     * @param symbol Ticker symbol of the asset\n     * @param logo Logo of the asset as a SVG string\n     * @param blockchainId Chain-ID of the native blockchain\n     * @param blockchainName Name of the native blockchain\n     * @param blockchainAddress Address of the asset on the native blockchain\n     * @param blockchainDecimals Number of decimals used by the asset\n     */\n    struct AssetData {\n        address id;\n        string name;\n        string symbol;\n        string logo;\n        uint256 blockchainId;\n        string blockchainName;\n        string blockchainAddress;\n        uint8 blockchainDecimals;\n    }\n}\n"
    },
    "contracts/interfaces/IAssetManagement.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\nimport \"./IAsset.sol\";\nimport \"../Asset.sol\";\n\n/**\n * @title IAssetManagement\n * Interface to manage assets in the Portal ecosystem\n */\ninterface IAssetManagement {\n    /**\n     * Creates a new asset.\n     * NOTE: This method is only callable by the owner of the contract.\n     */\n    function createAsset(IAsset.AssetData calldata asset) external;\n\n    /**\n     * Retrieves the specified asset\n     * @param id The address of the asset on the portal chain\n     * @return The asset whose id was provided\n     */\n    function retrieveAsset(\n        address id\n    ) external view returns (IAsset.AssetData memory);\n\n    /**\n     * Retrieves an asset using native blockchain properties\n     * @param blockchainName Name of the native blockchain\n     * @param blockchainAddress Address of the asset on the native blockchain\n     * @return The asset whose native blockchain properties were provided\n     */\n    function retrieveAssetByNativeProps(\n        string memory blockchainName,\n        string memory blockchainAddress\n    ) external view returns (IAsset.AssetData memory);\n\n    /**\n     * Lists all assets on the portal chain in the order they were created\n     * @return The list of all assets in the order they were created\n     */\n    function listAssets() external view returns (IAsset.AssetData[] memory);\n\n    /**\n     * Fires when a new asset is created\n     * @param id The address of the asset on the portal chain\n     */\n    event AssetCreated(address indexed id);\n\n    /**\n     * Thrown when the caller is not the owner of the contract\n     * @param sender The address of the account calling the function\n     */\n    error NotOwner(address sender);\n\n    /**\n     * Thrown when an asset has already been created\n     * @param blockchainName Name of the native blockchain\n     * @param blockchainAddress Address of the asset on the native blockchain\n     */\n    error AssetExists(string blockchainName, string blockchainAddress);\n}\n"
    },
    "contracts/interfaces/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\n/**\n * @title ILiquidityPool\n * @dev Interface for the LiquidityPool contract that defines functions for managing liquidity pools.\n */\ninterface ILiquidityPool {\n      /**\n     * @dev Data Structure of AssetPair\n     * @param id The unique identifier of the pool\n     * @param baseAsset The address of the base asset\n     * @param quoteAsset The address of the quote asset\n     * @param poolFee The pool fee\n     * @param minOrderSize The minimum order size for the base asset\n     * @param maxOrderSize The maximum order size for the base asset\n     */\n    struct LiquidityPool {\n        bytes32 id;\n        address baseAsset;\n        address quoteAsset;\n        uint poolFee;\n        uint minOrderSize;\n        uint maxOrderSize;\n    }\n\n    /**\n     * @dev creation of a liquidity pool for new pair and emit the event\n     * @param pool Properties of the liquidity pool\n     */\n    function createLiquidityPool(LiquidityPool memory pool) external;\n\n    /**\n     * @notice function to retrieve liquidityPoolId from pair details\n     * @param sellAsset Trader's sell asset address\n     * @param buyAsset Trader's buy asset address\n     * @param poolFee Fee of the trading pool\n     * @return liquidityPoolId liquidityPoolId of the pool\n     */\n    function retrievePoolId(\n        address sellAsset,\n        address buyAsset,\n        uint poolFee\n    ) external view returns (bytes32);\n\n    /**\n     * Retrieves a liquidity pool by its unique identifier\n     * @param id The unique identifier of the liquidity pool\n     * @return The liquidity pool whose id was provided\n     */\n    function retrievePool(bytes32 id) external view returns (LiquidityPool memory);\n\n    /**\n     * Lists all liquidity pools on the portal chain\n     * @return The list of all liquidity pools\n     */\n    function listPools() external view returns (LiquidityPool[] memory);\n\n    /**\n     * @dev Event emitted after a pair is registered\n     * @param liquidityPoolId The liquidityPoolId of the pair\n     */\n    event LiquidityPoolCreated(\n        bytes32 liquidityPoolId\n    );\n\n    // Custom errors\n    /**\n     * @dev Error that is thrown when the caller is not the owner of the contract\n     * @param sender the address of the sender\n     */\n    error NotOwner(address sender);\n\n}\n"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\nimport \"./IUniswapPositionManager.sol\";\nimport \"../uniswap/core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n/**\n * @title IPoolManager\n * @dev The  Pool Manager interface defines the functions for managing liquidity pools and positions on Uniswap V3.\n * @notice This interface is used to interact with the  Pool Manager contract.\n */\ninterface IPoolManager {\n    /**\n     * @dev Struct to represent Uniswap parameters.\n     * @param admin The address of the admin.\n     * @param factory The address of the Uniswap V3 factory.\n     * @param nft The address of the NFT.\n     * @param router The address of the router.\n     */\n    struct UniswapParams {\n        address admin;\n        address factory;\n        address nft;\n        address router;\n    }\n\n    /**\n     * @dev Struct to represent a liquidity position.\n     * @param tokenId The ID of the liquidity token.\n     * @param liquidity The amount of liquidity.\n     */\n    struct LiquidityPosition {\n        uint tokenId;\n        uint128 liquidity;\n    }\n\n    /**\n     * @dev Struct to represent an LP token.\n     * @param addr The address of the LP token.\n     * @param amountDesired The desired amount of the LP token.\n     * @param amountMin The minimum amount of the LP token.\n     */\n\n    struct LpToken {\n        address addr;\n        uint256 amountDesired;\n        uint256 amountMin;\n    }\n\n    /**\n     * @dev Returns the address of the pool for the given tokens and fee.\n     * @param tokenA The address of token A.\n     * @param tokenB The address of token B.\n     * @param fee The fee of the pool.\n     * @return pool The address of the pool.\n     */\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /**\n     * @dev Creates a new pool for the given tokens and fee.\n     * @param sellAsset The address of the sell asset.\n     * @param buyAsset The address of the buy asset.\n     * @param poolFee The fee of the pool.\n     */\n    function createPool(\n        address sellAsset,\n        address buyAsset,\n        uint24 poolFee\n    ) external;\n\n    /**\n     * @dev Creates a new liquidity position for the given assets and owner.\n     * @param sellAsset The LP token for the sell asset.\n     * @param buyAsset The LP token for the buy asset.\n     * @param owner The address of the owner.\n     * @param poolFee The fee of the pool.\n     * @param deadline The deadline for the transaction.\n     * @param tickLower The lower tick for the position.\n     * @param tickUpper The upper tick for the position.\n     */\n    function createPosition(\n        LpToken calldata sellAsset,\n        LpToken calldata buyAsset,\n        address owner,\n        uint24 poolFee,\n        uint deadline,\n        int24 tickLower,\n        int24 tickUpper\n    ) external;\n\n    /**\n     * @dev Increases the liquidity of the given position.\n     * @param tokenId The ID of the liquidity token.\n     * @param sellAsset The LP token for the sell asset.\n     * @param buyAsset The LP token for the buy asset.\n     * @param deadline The deadline for the transaction.\n     */\n    function increaseLiquidity(\n        uint256 tokenId,\n        LpToken calldata sellAsset,\n        LpToken calldata buyAsset,\n        uint deadline\n    ) external;\n\n    /**\n     * @dev Decreases the liquidity of the given position.\n     * @param owner The address of the owner.\n     * @param amount0Min The minimum amount of token 0.\n     * @param amount1Min The minimum amount of token 1.\n     * @param deadline The deadline for the transaction.\n     */\n    function decreaseLiquidity(\n        address owner,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        uint256 deadline\n    ) external;\n\n    /**\n     * @dev Executes an exact input single swap.\n     * @param tokenIn The address of the input token.\n     * @param tokenOut The address of the output token.\n     * @param fee The fee of the pool.\n     * @param amountIn The amount of the input token.\n     * @return amountOut The amount of the output token.\n     */\n    function exactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) external payable returns (uint256 amountOut);\n\n    /**\n     * @dev Returns the address of the Uniswap V3 factory.\n     * @return pool The address of the factory.\n     */\n    function factory() external view returns (IUniswapV3Factory pool);\n\n    /**\n     * @dev Sets the initial sqrt price for the given pool.\n     * @param sellToken The address of the sell token.\n     * @param buyToken The address of the buy token.\n     * @param fee The fee of the pool.\n     * @param sqrtPriceX96 The initial sqrt price.\n     */\n    function setInitialSqrtPrice(\n        address sellToken,\n        address buyToken,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external;\n\n    /**\n     * @dev Returns the current sqrt price for the given pool.\n     * @param tokenA The address of token A.\n     * @param tokenB The address of token B.\n     * @param fee The fee of the pool.\n     * @return sqrtPriceX96 The current sqrt price.\n     */\n    function getPoolPrice(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (uint160 sqrtPriceX96);\n\n    /**\n     * @dev Error thrown when no enabled tick spacing is found for the given pool fee.\n     * @param poolFee The pool fee for which no enabled tick spacing was found.\n     */\n    error NoEnabledTickSpacing(uint poolFee);\n\n    /**\n     * @dev Error thrown when no admin is found for the given address.\n     * @param sender The address for which no admin was found.\n     */\n    error NoAdmin(address sender);\n\n    /**\n     * @dev Error thrown when no initial sqrt price is set for the given sell and buy assets.\n     * @param sellAsset The address of the sell asset.\n     * @param buyAsset The address of the buy asset.\n     * @param fee The fee of the pool.\n     */\n    error NoInitialSqrtPrice(address sellAsset, address buyAsset, uint160 fee);\n}\n"
    },
    "contracts/interfaces/IPortalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IPortalToken\n * The Portal Token interface defines functions for the PORTAL token with\n * respect to the auction process for validators. This contract is relevant on\n * the Portal chain.\n */\ninterface IPortalToken is IERC20 {\n    /**\n     * @dev Returns the address of the owner of the PORTAL Token contract. This\n     * should be the address of the Portal Foundation.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * Returns the number of tokens locked by a potential validator (bidder)\n     * @param _user Address of the potential validator (bidder)\n     * @return The number of tokens locked by the potential validator (bidder)\n     */\n    function getLockedTokens(address _user) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IUniswapPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\ninterface IUniswapPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n\n}"
    },
    "contracts/interfaces/IUniswapPositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IUniswapPositionManager {\n\n     function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/interfaces/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IUniswapSwapRouter {\n    \n}"
    },
    "contracts/uniswap/core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n    function addAdmin(address _admin) external;\n    function removeAdmin(address _admin) external;\n    function isAdmin(address _admin) external returns(bool);\n}\n"
    },
    "contracts/uniswap/core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(uint24(MAX_TICK)), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n\n\n    // New function: Calculates the minimum tick for a given tick spacing\n    function getMinTick(int24 tickSpacing) internal pure returns (int24) {\n        require(tickSpacing > 0, \"Invalid tick spacing\");\n        return (MIN_TICK / tickSpacing) * tickSpacing;\n    }\n\n    // New function: Calculates the maximum tick for a given tick spacing\n    function getMaxTick(int24 tickSpacing) internal pure returns (int24) {\n        require(tickSpacing > 0, \"Invalid tick spacing\");\n        return (MAX_TICK / tickSpacing) * tickSpacing;\n    }\n\n    // New function: Calculates the maximum liquidity per tick for a given tick spacing\n    function getMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint256) {\n        require(tickSpacing > 0, \"Invalid tick spacing\");\n        int24 minTick = getMinTick(tickSpacing);\n        int24 maxTick = getMaxTick(tickSpacing);\n        uint256 tickRange = uint256(int256(maxTick - minTick) / int256(tickSpacing) + 1);\n        return type(uint256).max / tickRange;\n    }\n\n    \n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}