{
  "language": "Solidity",
  "sources": {
    "@gnosis.pm/safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {Enum} from \"../libraries/Enum.sol\";\n\n/**\n * @title Executor - A contract that can execute transactions\n * @author Richard Meissner - @rmeissner\n */\nabstract contract Executor {\n    /**\n     * @notice Executes either a delegatecall or a call with provided parameters.\n     * @dev This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @return success boolean flag indicating if the call succeeded.\n     */\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            /* solhint-disable no-inline-assembly */\n            /// @solidity memory-safe-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n            /* solhint-enable no-inline-assembly */\n        } else {\n            /* solhint-disable no-inline-assembly */\n            /// @solidity memory-safe-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n            /* solhint-enable no-inline-assembly */\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IFallbackManager} from \"../interfaces/IFallbackManager.sol\";\n\n/**\n * @title Fallback Manager - A contract managing fallback calls made to this contract\n * @author Richard Meissner - @rmeissner\n */\nabstract contract FallbackManager is SelfAuthorized, IFallbackManager {\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /**\n     *  @notice Internal function to set the fallback handler.\n     *  @param handler contract to handle fallback calls.\n     */\n    function internalSetFallbackHandler(address handler) internal {\n        /*\n            If a fallback handler is set to self, then the following attack vector is opened:\n            Imagine we have a function like this:\n            function withdraw() internal authorized {\n                withdrawalAddress.call.value(address(this).balance)(\"\");\n            }\n\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\n        */\n        if (handler == address(this)) revertWithError(\"GS400\");\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    // @inheritdoc IFallbackManager\n    function setFallbackHandler(address handler) public override authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n    //      The handler can make us of `HandlerContext.sol` to extract the address.\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\n    //      and having the original caller address may enable additional verification scenarios.\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // When compiled with the optimizer, the compiler relies on a certain assumptions on how the\n            // memory is used, therefore we need to guarantee memory safety (keeping the free memory point 0x40 slot intact,\n            // not going beyond the scratch space, etc)\n            // Solidity docs: https://docs.soliditylang.org/en/latest/assembly.html#memory-safety\n\n            let handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n\n            if iszero(handler) {\n                return(0, 0)\n            }\n\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(add(ptr, calldatasize()), shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, ptr, add(calldatasize(), 20), 0, 0)\n\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            return(ptr, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"../libraries/Enum.sol\";\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IGuardManager} from \"../interfaces/IGuardManager.sol\";\n\n/// @title Guard Interface\ninterface Guard is IERC165 {\n    /// @notice Checks the transaction details.\n    /// @dev The function needs to implement transaction validation logic.\n    /// @param to The address to which the transaction is intended.\n    /// @param value The value of the transaction in Wei.\n    /// @param data The transaction data.\n    /// @param operation The type of operation of the transaction.\n    /// @param safeTxGas Gas used for the transaction.\n    /// @param baseGas The base gas for the transaction.\n    /// @param gasPrice The price of gas in Wei for the transaction.\n    /// @param gasToken The token used to pay for gas.\n    /// @param refundReceiver The address which should receive the refund.\n    /// @param signatures The signatures of the transaction.\n    /// @param msgSender The address of the message sender.\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    /// @notice Checks the module transaction details.\n    /// @dev The function needs to implement module transaction validation logic.\n    /// @param to The address to which the transaction is intended.\n    /// @param value The value of the transaction in Wei.\n    /// @param data The transaction data.\n    /// @param operation The type of operation of the transaction.\n    /// @param module The module involved in the transaction.\n    /// @return moduleTxHash The hash of the module transaction.\n    function checkModuleTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        address module\n    ) external returns (bytes32 moduleTxHash);\n\n    /// @notice Checks after execution of transaction.\n    /// @dev The function needs to implement a check after the execution of the transaction.\n    /// @param hash The hash of the transaction.\n    /// @param success The status of the transaction execution.\n    function checkAfterExecution(bytes32 hash, bool success) external;\n}\n\nabstract contract BaseGuard is Guard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(Guard).interfaceId || // 0x945b8148\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/**\n * @title Guard Manager - A contract managing transaction guards which perform pre and post-checks on Safe transactions.\n * @author Richard Meissner - @rmeissner\n */\nabstract contract GuardManager is SelfAuthorized, IGuardManager {\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    // @inheritdoc IGuardManager\n    function setGuard(address guard) external override authorized {\n        if (guard != address(0) && !Guard(guard).supportsInterface(type(Guard).interfaceId)) revertWithError(\"GS300\");\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(GUARD_STORAGE_SLOT, guard)\n        }\n        /* solhint-enable no-inline-assembly */\n        emit ChangedGuard(guard);\n    }\n\n    /**\n     * @dev Internal method to retrieve the current guard\n     *      We do not have a public method because we're short on bytecode size limit,\n     *      to retrieve the guard address, one can use `getStorageAt` from `StorageAccessible` contract\n     *      with the slot `GUARD_STORAGE_SLOT`\n     * @return guard The address of the guard\n     */\n    function getGuard() internal view returns (address guard) {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            guard := sload(GUARD_STORAGE_SLOT)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {Enum} from \"../libraries/Enum.sol\";\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {Executor} from \"./Executor.sol\";\nimport {GuardManager, Guard} from \"./GuardManager.sol\";\nimport {IModuleManager} from \"../interfaces/IModuleManager.sol\";\n\n/**\n * @title Module Manager - A contract managing Safe modules\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \n           so only trusted and audited modules should be added to a Safe. A malicious module can\n           completely takeover a Safe.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\nabstract contract ModuleManager is SelfAuthorized, Executor, GuardManager, IModuleManager {\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    /**\n     * @notice Setup function sets the initial storage of the contract.\n     *         Optionally executes a delegate call to another contract to setup the modules.\n     * @param to Optional destination address of call to execute.\n     * @param data Optional data of call to execute.\n     */\n    function setupModules(address to, bytes memory data) internal {\n        if (modules[SENTINEL_MODULES] != address(0)) revertWithError(\"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0)) {\n            if (!isContract(to)) revertWithError(\"GS002\");\n            // Setup has to complete successfully or transaction fails.\n            if (!execute(to, 0, data, Enum.Operation.DelegateCall, type(uint256).max)) revertWithError(\"GS000\");\n        }\n    }\n\n    /**\n     * @notice Runs pre-execution checks for module transactions if a guard is enabled.\n     * @param to Target address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return guard Guard to be used for checking.\n     * @return guardHash Hash returned from the guard tx check.\n     */\n    function preModuleExecution(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (address guard, bytes32 guardHash) {\n        guard = getGuard();\n\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n\n        if (guard != address(0)) {\n            guardHash = Guard(guard).checkModuleTransaction(to, value, data, operation, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Runs post-execution checks for module transactions if a guard is enabled.\n     * @param guardHash Hash returned from the guard during pre execution check.\n     * @param success Boolean flag indicating if the call succeeded.\n     * @param guard Guard to be used for checking.\n     * @dev Emits event based on module transaction success.\n     */\n    function postModuleExecution(address guard, bytes32 guardHash, bool success) internal {\n        if (guard != address(0)) {\n            Guard(guard).checkAfterExecution(guardHash, success);\n        }\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    // @inheritdoc IModuleManager\n    function enableModule(address module) public override authorized {\n        // Module address cannot be null or sentinel.\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\n        // Module cannot be added twice.\n        if (modules[module] != address(0)) revertWithError(\"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    // @inheritdoc IModuleManager\n    function disableModule(address prevModule, address module) public override authorized {\n        // Validate module address and check that it corresponds to module index.\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\n        if (modules[prevModule] != module) revertWithError(\"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    // @inheritdoc IModuleManager\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual override returns (bool success) {\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\n        success = execute(to, value, data, operation, type(uint256).max);\n        postModuleExecution(guard, guardHash, success);\n    }\n\n    // @inheritdoc IModuleManager\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success, bytes memory returnData) {\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\n        success = execute(to, value, data, operation, type(uint256).max);\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load free memory location\n            returnData := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(returnData, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(returnData, returndatasize())\n            // Store the data\n            returndatacopy(add(returnData, 0x20), 0, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n        postModuleExecution(guard, guardHash, success);\n    }\n\n    // @inheritdoc IModuleManager\n    function isModuleEnabled(address module) public view override returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    // @inheritdoc IModuleManager\n    function getModulesPaginated(address start, uint256 pageSize) external view override returns (address[] memory array, address next) {\n        if (start != SENTINEL_MODULES && !isModuleEnabled(start)) revertWithError(\"GS105\");\n        if (pageSize == 0) revertWithError(\"GS106\");\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        next = modules[start];\n        while (next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = next;\n            next = modules[next];\n            moduleCount++;\n        }\n\n        /**\n          Because of the argument validation, we can assume that the loop will always iterate over the valid module list values\n          and the `next` variable will either be an enabled module or a sentinel address (signalling the end). \n          \n          If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the modules array\n          because the `next` variable (which is a module by itself) acting as a pointer to the start of the next page is neither \n          included to the current page, nor will it be included in the next one if you pass it as a start.\n        */\n        if (next != SENTINEL_MODULES) {\n            next = array[moduleCount - 1];\n        }\n        // Set correct size of returned array\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *      as the code is not actually created until after the constructor finishes.\n     * @param account The address being queried\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        /* solhint-enable no-inline-assembly */\n        return size > 0;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IOwnerManager} from \"../interfaces/IOwnerManager.sol\";\n\n/**\n * @title OwnerManager - Manages Safe owners and a threshold to authorize transactions.\n * @dev Uses a linked list to store the owners because the code generate by the solidity compiler\n *      is more efficient than using a dynamic array.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\nabstract contract OwnerManager is SelfAuthorized, IOwnerManager {\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /**\n     * @notice Sets the initial storage of the contract.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     */\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        if (threshold > 0) revertWithError(\"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        if (_threshold > _owners.length) revertWithError(\"GS201\");\n        // There has to be at least one Safe owner.\n        if (_threshold == 0) revertWithError(\"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || currentOwner == owner)\n                revertWithError(\"GS203\");\n            // No duplicate owners allowed.\n            if (owners[owner] != address(0)) revertWithError(\"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    // @inheritdoc IOwnerManager\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public override authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this)) revertWithError(\"GS203\");\n        // No duplicate owners allowed.\n        if (owners[owner] != address(0)) revertWithError(\"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    // @inheritdoc IOwnerManager\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) public override authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        if (ownerCount - 1 < _threshold) revertWithError(\"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        if (owner == address(0) || owner == SENTINEL_OWNERS) revertWithError(\"GS203\");\n        if (owners[prevOwner] != owner) revertWithError(\"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    // @inheritdoc IOwnerManager\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) public override authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        if (newOwner == address(0) || newOwner == SENTINEL_OWNERS || newOwner == address(this)) revertWithError(\"GS203\");\n        // No duplicate owners allowed.\n        if (owners[newOwner] != address(0)) revertWithError(\"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        if (oldOwner == address(0) || oldOwner == SENTINEL_OWNERS) revertWithError(\"GS203\");\n        if (owners[prevOwner] != oldOwner) revertWithError(\"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    // @inheritdoc IOwnerManager\n    function changeThreshold(uint256 _threshold) public override authorized {\n        // Validate that threshold is smaller than number of owners.\n        if (_threshold > ownerCount) revertWithError(\"GS201\");\n        // There has to be at least one Safe owner.\n        if (_threshold == 0) revertWithError(\"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    // @inheritdoc IOwnerManager\n    function getThreshold() public view override returns (uint256) {\n        return threshold;\n    }\n\n    // @inheritdoc IOwnerManager\n    function isOwner(address owner) public view override returns (bool) {\n        return !(owner == SENTINEL_OWNERS || owners[owner] == address(0));\n    }\n\n    // @inheritdoc IOwnerManager\n    function getOwners() public view override returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/NativeCurrencyPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title NativeCurrencyPaymentFallback - A contract that has a fallback to accept native currency payments.\n * @author Richard Meissner - @rmeissner\n */\nabstract contract NativeCurrencyPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /**\n     * @notice Receive function accepts native currency transactions.\n     * @dev Emits an event with sender and received value.\n     */\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title SecuredTokenTransfer - Secure token transfer.\n * @author Richard Meissner - @rmeissner\n */\nabstract contract SecuredTokenTransfer {\n    /**\n     * @notice Transfers a token and returns a boolean if it was a success\n     * @dev It checks the return data of the transfer call and returns true if the transfer was successful.\n     *      It doesn't check if the `token` address is a contract or not.\n     * @param token Token that should be transferred\n     * @param receiver Receiver to whom the token should be transferred\n     * @param amount The amount of tokens that should be transferred\n     * @return transferred Returns true if the transfer was successful\n     */\n    function transferToken(address token, address receiver, uint256 amount) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n            case 0 {\n                transferred := success\n            }\n            case 0x20 {\n                transferred := iszero(or(iszero(success), iszero(mload(0))))\n            }\n            default {\n                transferred := 0\n            }\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ErrorMessage} from \"../libraries/ErrorMessage.sol\";\n\n/**\n * @title SelfAuthorized - Authorizes current contract to perform actions to itself.\n * @author Richard Meissner - @rmeissner\n */\nabstract contract SelfAuthorized is ErrorMessage {\n    function requireSelfCall() private view {\n        if (msg.sender != address(this)) revertWithError(\"GS031\");\n    }\n\n    modifier authorized() {\n        // Modifiers are copied around during compilation. This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title SignatureDecoder - Decodes signatures encoded as bytes\n * @author Richard Meissner - @rmeissner\n */\nabstract contract SignatureDecoder {\n    /**\n     * @notice Splits signature bytes into `uint8 v, bytes32 r, bytes32 s`.\n     * @dev Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n     *      The signature format is a compact form of {bytes32 r}{bytes32 s}{uint8 v}\n     *      Compact means uint8 is not padded to 32 bytes.\n     * @param pos Which signature to read.\n     *            A prior bounds check of this parameter should be performed, to avoid out of bounds access.\n     * @param signatures Concatenated {r, s, v} signatures.\n     * @return v Recovery ID or Safe signature type.\n     * @return r Output value r of the signature.\n     * @return s Output value s of the signature.\n     */\n    function signatureSplit(bytes memory signatures, uint256 pos) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Singleton - Base for singleton contracts (should always be the first super contract)\n *        This contract is tightly coupled to our proxy contract (see `proxies/SafeProxy.sol`)\n * @author Richard Meissner - @rmeissner\n */\nabstract contract Singleton {\n    // singleton always has to be the first declared variable to ensure the same location as in the Proxy contract.\n    // It should also always be ensured the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title StorageAccessible - A generic base contract that allows callers to access all internal storage.\n * @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\n *         It removes a method from the original contract not needed for the Safe Smart Account contracts.\n * @author Gnosis Developers\n */\nabstract contract StorageAccessible {\n    /**\n     * @notice Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            /* solhint-disable no-inline-assembly */\n            /// @solidity memory-safe-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n            /* solhint-enable no-inline-assembly */\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegatecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n            // Load free memory location\n            let ptr := mload(0x40)\n            mstore(ptr, success)\n            mstore(add(ptr, 0x20), returndatasize())\n            returndatacopy(add(ptr, 0x40), 0, returndatasize())\n            revert(ptr, add(returndatasize(), 0x40))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/external/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title SafeMath\n * @notice Math operations with safety checks that revert on error (overflow/underflow)\n */\nlibrary SafeMath {\n    /**\n     * @notice Multiplies two numbers, reverts on overflow.\n     * @param a First number\n     * @param b Second number\n     * @return Product of a and b\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @notice Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     * @param a First number\n     * @param b Second number\n     * @return Difference of a and b\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @notice Adds two numbers, reverts on overflow.\n     * @param a First number\n     * @param b Second number\n     * @return Sum of a and b\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @notice Returns the largest of two numbers.\n     * @param a First number\n     * @param b Second number\n     * @return Largest of a and b\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\n     * See the corresponding EIP section\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IFallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\n * @author @safe-global/safe-protocol\n */\ninterface IFallbackManager {\n    event ChangedFallbackHandler(address indexed handler);\n\n    /**\n     * @notice Set Fallback Handler to `handler` for the Safe.\n     * @dev Only fallback calls without value and with data will be forwarded.\n     *      This can only be done via a Safe transaction.\n     *      Cannot be set to the Safe itself.\n     * @param handler contract to handle fallback calls.\n     */\n    function setFallbackHandler(address handler) external;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IGuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\n * @author @safe-global/safe-protocol\n */\ninterface IGuardManager {\n    event ChangedGuard(address indexed guard);\n\n    /**\n     * @dev Set a guard that checks transactions before execution\n     *      This can only be done via a Safe transaction.\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\n     *        audit the guard code and design recovery mechanisms.\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\n     */\n    function setGuard(address guard) external;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {Enum} from \"../libraries/Enum.sol\";\nimport {IGuardManager} from \"./IGuardManager.sol\";\n\n/**\n * @title IModuleManager - An interface of contract managing Safe modules\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \n           so only trusted and audited modules should be added to a Safe. A malicious module can\n           completely takeover a Safe.\n * @author @safe-global/safe-protocol\n */\ninterface IModuleManager is IGuardManager {\n    event EnabledModule(address indexed module);\n    event DisabledModule(address indexed module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be whitelisted.\n     */\n    function enableModule(address module) external;\n\n    /**\n     * @notice Disables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param prevModule Previous module in the modules linked list.\n     * @param module Module to be removed.\n     */\n    function disableModule(address prevModule, address module) external;\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\n     * @dev Function is virtual to allow overriding for L2 singleton to emit an event for indexing.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /**\n     * @notice Returns if an module is enabled\n     * @return True if the module is enabled\n     */\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /**\n     * @notice Returns an array of modules.\n     *         If all entries fit into a single page, the next pointer will be 0x1.\n     *         If another page is present, next will be the last element of the returned array.\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IOwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\n * @author @safe-global/safe-protocol\n */\ninterface IOwnerManager {\n    event AddedOwner(address indexed owner);\n    event RemovedOwner(address indexed owner);\n    event ChangedThreshold(uint256 threshold);\n\n    /**\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n     * @dev This can only be done via a Safe transaction.\n     * @param owner New owner address.\n     * @param _threshold New threshold.\n     */\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\n\n    /**\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n     * @dev This can only be done via a Safe transaction.\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\n     * @param owner Owner address to be removed.\n     * @param _threshold New threshold.\n     */\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\n\n    /**\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n     * @dev This can only be done via a Safe transaction.\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n     * @param oldOwner Owner address to be replaced.\n     * @param newOwner New owner address.\n     */\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\n\n    /**\n     * @notice Changes the threshold of the Safe to `_threshold`.\n     * @dev This can only be done via a Safe transaction.\n     * @param _threshold New threshold.\n     */\n    function changeThreshold(uint256 _threshold) external;\n\n    /**\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\n     * @return Threshold number.\n     */\n    function getThreshold() external view returns (uint256);\n\n    /**\n     * @notice Returns if `owner` is an owner of the Safe.\n     * @return Boolean if owner is an owner of the Safe.\n     */\n    function isOwner(address owner) external view returns (bool);\n\n    /**\n     * @notice Returns a list of Safe owners.\n     * @return Array of Safe owners.\n     */\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Enum} from \"../libraries/Enum.sol\";\nimport {IModuleManager} from \"./IModuleManager.sol\";\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\n\n/**\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\n * @author @safe-global/safe-protocol\n */\ninterface ISafe is IModuleManager, IOwnerManager, IFallbackManager {\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\n     * @dev The fees are always transferred, even if the user transaction fails.\n     *      This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      It is the responsibility of the caller to perform such checks.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param safeTxGas Gas that should be used for the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) external view;\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @dev This function makes it compatible with previous versions.\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory /* IGNORED */, bytes memory signatures) external view;\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\n     * @param executor Address that executing the transaction.\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitmate executor.\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\n\n    /**\n     * @notice Marks hash `hashToApprove` as approved.\n     * @dev This can be used with a pre-approved hash transaction signature.\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external;\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n\n    /**\n     * External getter function for state variables.\n     */\n\n    /**\n     * @notice Returns the version of the Safe contract.\n     * @return Version string.\n     */\n    // solhint-disable-next-line\n    function VERSION() external view returns (string memory);\n\n    /**\n     * @notice Returns the nonce of the Safe contract.\n     * @return Nonce.\n     */\n    function nonce() external view returns (uint256);\n\n    /**\n     * @notice Returns a uint if the messageHash is signed by the owner.\n     * @param messageHash Hash of message that should be checked.\n     * @return Number denoting if an owner signed the hash.\n     */\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\n\n    /**\n     * @notice Returns a uint if the messageHash is approved by the owner.\n     * @param owner Owner address that should be checked.\n     * @param messageHash Hash of message that should be checked.\n     * @return Number denoting if an owner approved the hash.\n     */\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @notice EIP1271 method to validate a signature.\n     * @param _hash Hash of the data signed on the behalf of address(this).\n     * @param _signature Signature byte array associated with _data.\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view virtual returns (bytes4);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/libraries/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\n * @author @safe-global/safe-protocol\n */\nlibrary Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/libraries/ErrorMessage.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Error Message - Contract which uses assembly to revert with a custom error message.\n * @author Shebin John - @remedcu\n * @notice The aim is to save gas using assembly to revert with custom error message.\n */\nabstract contract ErrorMessage {\n    /**\n     * @notice Function which uses assembly to revert with the passed error message.\n     * @param error The error string to revert with.\n     * @dev Currently it is expected that the `error` string is at max 5 bytes of length. Ex: \"GSXXX\"\n     */\n    function revertWithError(bytes5 error) internal pure {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Selector for method \"Error(string)\"\n            mstore(add(ptr, 0x04), 0x20) // String offset\n            mstore(add(ptr, 0x24), 0x05) // Revert reason length (5 bytes for bytes5)\n            mstore(add(ptr, 0x44), error) // Revert reason\n            revert(ptr, 0x64) // Revert data length is 4 bytes for selector + offset + error length + error.\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport {SafeProxy} from \"./SafeProxy.sol\";\n\n/**\n * @title IProxyCreationCallback\n * @dev An interface for a contract that implements a callback function to be executed after the creation of a proxy instance.\n */\ninterface IProxyCreationCallback {\n    /**\n     * @dev Function to be called after the creation of a SafeProxy instance.\n     * @param proxy The newly created SafeProxy instance.\n     * @param _singleton The address of the singleton contract used to create the proxy.\n     * @param initializer The initializer function call data.\n     * @param saltNonce The nonce used to generate the salt for the proxy deployment.\n     */\n    function proxyCreated(SafeProxy proxy, address _singleton, bytes calldata initializer, uint256 saltNonce) external;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/proxies/SafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n/* solhint-disable one-contract-per-file */\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title IProxy - Helper interface to access the singleton address of the Proxy on-chain.\n * @author Richard Meissner - @rmeissner\n */\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/**\n * @title SafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n * @author Stefan George - <stefan@gnosis.io>\n * @author Richard Meissner - <richard@gnosis.io>\n */\ncontract SafeProxy {\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /**\n     * @notice Constructor function sets address of singleton contract.\n     * @param _singleton Singleton address.\n     */\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := sload(0)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, shr(12, shl(12, _singleton)))\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/proxies/SafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SafeProxy} from \"./SafeProxy.sol\";\nimport {IProxyCreationCallback} from \"./IProxyCreationCallback.sol\";\n\n/**\n * @title Proxy Factory - Allows to create a new proxy contract and execute a message call to the new proxy within one transaction.\n * @author Stefan George - @Georgi87\n */\ncontract SafeProxyFactory {\n    event ProxyCreation(SafeProxy indexed proxy, address singleton);\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(SafeProxy).creationCode;\n    }\n\n    /**\n     * @notice Internal method to create a new proxy contract using CREATE2. Optionally executes an initializer call to a new proxy.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer (Optional) Payload for a message call to be sent to a new proxy contract.\n     * @param salt Create2 salt to use for calculating the address of the new proxy contract.\n     * @return proxy Address of the new proxy contract.\n     */\n    function deployProxy(address _singleton, bytes memory initializer, bytes32 salt) internal returns (SafeProxy proxy) {\n        require(isContract(_singleton), \"Singleton contract not deployed\");\n\n        bytes memory deploymentData = abi.encodePacked(type(SafeProxy).creationCode, uint256(uint160(_singleton)));\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        /* solhint-enable no-inline-assembly */\n        require(address(proxy) != address(0), \"Create2 call failed\");\n\n        if (initializer.length > 0) {\n            /* solhint-disable no-inline-assembly */\n            /// @solidity memory-safe-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n            /* solhint-enable no-inline-assembly */\n        }\n    }\n\n    /**\n     * @notice Deploys a new proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     */\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce) public returns (SafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        proxy = deployProxy(_singleton, initializer, salt);\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /**\n     * @notice Deploys a new chain-specific proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\n     * @dev Allows to create a new proxy contract that should exist only on 1 network (e.g. specific governance or admin accounts)\n     *      by including the chain id in the create2 salt. Such proxies cannot be created on other networks by replaying the transaction.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     */\n    function createChainSpecificProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (SafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce, getChainId()));\n        proxy = deployProxy(_singleton, initializer, salt);\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /**\n     * @notice Deploy a new proxy with `_singleton` singleton and `saltNonce` salt.\n     *         Optionally executes an initializer call to a new proxy and calls a specified callback address `callback`.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     * @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n     */\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (SafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *      as the code is not actually created until after the constructor finishes.\n     * @param account The address being queried\n     * @return True if `account` is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        /* solhint-enable no-inline-assembly */\n        return size > 0;\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            id := chainid()\n        }\n        /* solhint-enable no-inline-assembly */\n        return id;\n    }\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/Safe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {Guard} from \"./base/GuardManager.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {OwnerManager} from \"./base/OwnerManager.sol\";\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {NativeCurrencyPaymentFallback} from \"./common/NativeCurrencyPaymentFallback.sol\";\nimport {Singleton} from \"./common/Singleton.sol\";\nimport {SignatureDecoder} from \"./common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\nimport {StorageAccessible} from \"./common/StorageAccessible.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"./interfaces/ISignatureValidator.sol\";\nimport {SafeMath} from \"./external/SafeMath.sol\";\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guard: Guard is a contract that can execute pre- and post- transaction checks. Managed in `GuardManager`.\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    ISafe\n{\n    using SafeMath for uint256;\n\n    string public constant override VERSION = \"1.4.1\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    uint256 public override nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public override signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public override approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    // @inheritdoc ISafe\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external override {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    // @inheritdoc ISafe\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            txHash = getTransactionHash( // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                // We use the post-increment here, so the current nonce value is used and incremented afterwards.\n                nonce++\n            );\n            checkSignatures(txHash, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        if (gasleft() < ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500) revertWithError(\"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && safeTxGas == 0 && gasPrice == 0) revertWithError(\"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n            if (!refundSuccess) revertWithError(\"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            if (!transferToken(gasToken, receiver, payment)) revertWithError(\"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the contract signature is valid. Reverts otherwise.\n     * @dev This is extracted to a separate function for better compatibility with Certora's prover.\n     *      More info here: https://github.com/safe-global/safe-smart-account/pull/661\n     * @param owner Address of the owner used to sign the message\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     * @param offset Offset to the start of the contract signature in the signatures byte array\n     */\n    function checkContractSignature(address owner, bytes32 dataHash, bytes memory signatures, uint256 offset) internal view {\n        // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n        if (offset.add(32) > signatures.length) revertWithError(\"GS022\");\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n        uint256 contractSignatureLen;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, offset), 0x20))\n        }\n        /* solhint-enable no-inline-assembly */\n        if (offset.add(32).add(contractSignatureLen) > signatures.length) revertWithError(\"GS023\");\n\n        // Check signature\n        bytes memory contractSignature;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n            contractSignature := add(add(signatures, offset), 0x20)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        if (ISignatureValidator(owner).isValidSignature(dataHash, contractSignature) != EIP1271_MAGIC_VALUE) revertWithError(\"GS024\");\n    }\n\n    // @inheritdoc ISafe\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) public view override {\n        checkSignatures(dataHash, \"\", signatures);\n    }\n\n    // @inheritdoc ISafe\n    function checkSignatures(bytes32 dataHash, bytes memory /* IGNORED */, bytes memory signatures) public view override {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        if (_threshold == 0) revertWithError(\"GS001\");\n        checkNSignatures(msg.sender, dataHash, signatures, _threshold);\n    }\n\n    // @inheritdoc ISafe\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view override {\n        // Check that the provided signature data is not too short\n        if (signatures.length < requiredSignatures.mul(65)) revertWithError(\"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 v; // Implicit conversion from uint8 to uint256 will be done for v received from signatureSplit(...).\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                if (uint256(s) < requiredSignatures.mul(65)) revertWithError(\"GS021\");\n\n                // The contract signature check is extracted to a separate function for better compatibility with formal verification\n                // A quote from the Certora team:\n                // \"The assembly code broke the pointer analysis, which switched the prover in failsafe mode, where it is (a) much slower and (b) computes different hashes than in the normal mode.\"\n                // More info here: https://github.com/safe-global/safe-smart-account/pull/661\n                checkContractSignature(currentOwner, dataHash, signatures, uint256(s));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                if (executor != currentOwner && approvedHashes[currentOwner][dataHash] == 0) revertWithError(\"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), uint8(v - 4), r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, uint8(v), r, s);\n            }\n            if (currentOwner <= lastOwner || owners[currentOwner] == address(0) || currentOwner == SENTINEL_OWNERS)\n                revertWithError(\"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    // @inheritdoc ISafe\n    function approveHash(bytes32 hashToApprove) external override {\n        if (owners[msg.sender] == address(0)) revertWithError(\"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    // @inheritdoc ISafe\n    function domainSeparator() public view override returns (bytes32) {\n        uint256 chainId;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            chainId := chainid()\n        }\n        /* solhint-enable no-inline-assembly */\n\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) private view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // @inheritdoc ISafe\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view override returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/DexContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\nimport \"./interfaces/IPortalToken.sol\";\nimport {IDexContract} from \"./interfaces/IDexContract.sol\";\n\n/**\n * @title Dex contract\n * @dev Implementation of the Dex contract which manages swap order creation and all the steps for swap on evm \n */\ncontract DexContract is IDexContract {\n    /**\n     * @notice Address on the PORTAL Token contract\n     */\n    IPortalToken public tokenContract;\n\n    /**\n     * @notice Fee percentage in basis points (100 basis points = 1%)\n     */\n    uint public feePercentage; \n\n    /**\n     * @notice Notice to update fees\n     */\n    uint public feeUpdateNotice;\n\n    /**\n     * @notice Initialize the contract with portal token contract address, fee percentage, and fee update notice\n     * @param _tokenAddress Address of the Portal Token contract\n     */\n    constructor(address _tokenAddress) {\n        tokenContract = IPortalToken(_tokenAddress); //Loading the portal contract from portal token address\n        feePercentage = 30; // Initializing with a 0.3% fee\n        feeUpdateNotice = block.timestamp + 100000 days; //Initializing with higher notice\n    }\n\n    /**\n     * @notice Modifier to check if the caller is the owner of the token contract\n     */\n    modifier onlyOwner() {\n        if (tokenContract.owner() != msg.sender) {\n            revert NotOwner(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Mapping to store swap orders with their unique IDs\n     */\n    mapping(bytes32 => Order) public orders;\n\n    /**\n     * @notice Mapping to store authorized address and amounts with swapIds\n     */\n    mapping(bytes32 => AuthorizedWithdrawal[]) public authorized;\n\n    /**\n     * @notice Function to create a swap order\n     * @param secretHash Hash of the secret for the swap\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     * @param swapOwner Address of the trader initiating the swap\n     */\n    function swapOrder(\n        bytes32 secretHash,\n        address sellAsset,\n        uint sellAmount,\n        address swapOwner\n    ) public payable {\n        bytes32 swapId = keccak256(\n                            abi.encodePacked(\n                                secretHash,\n                                sellAsset,\n                                sellAmount,\n                                swapOwner\n                            )\n                        );\n\n        // Ensure no existing swap order with the same ID\n        require(orders[swapId].sellAmount == 0, \"Swap ID already exists\");\n\n        // Record a new swap order with provided parameters\n        orders[swapId] = Order({\n            secretHash: secretHash, // Hash of the secret\n            sellAsset: sellAsset, // Asset address to be sold (0x0 for ETH)\n            sellAmount: sellAmount, // Amount of the asset to be sold\n            swapOwner: swapOwner, // Address of the trader initiating the swap\n            swapId: swapId, // Unique identifier for the swap\n            swapCreation: block.timestamp // Timestamp of swap creation\n        });\n\n        // Handle ETH and ERC20 transfers differently\n        if (sellAsset == address(0x0)) {\n            if (msg.value != sellAmount) {\n                revert IncorrectETHAmount(sellAmount);\n            }\n        } else {\n            // Transfer ERC20 tokens from sender to contract\n            IERC20(sellAsset).transferFrom(\n                msg.sender,\n                address(this),\n                sellAmount\n            );\n        }\n\n        // Emit an event upon successful recording of the swap order\n        emit OrderCreated(\n            secretHash,\n            sellAsset,\n            sellAmount,\n            swapOwner,\n            swapId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Function to authorize the swap order\n     * @param swapId Unique identifier for the swap\n     * @param withdraws Array of authorized addresses and amounts for withdrawal\n     */\n    function authorize(\n        bytes32 swapId,\n        AuthorizedWithdrawal[] memory withdraws\n    ) public {\n        // Retrieve the swap details\n        Order storage swap = orders[swapId];\n\n        // Ensure validators' multisig or swapOwner sends this transaction\n\n        if (\n            msg.sender != tokenContract.owner() && msg.sender != swap.swapOwner\n        ) {\n            revert PermissionDeniedToAuthorize(msg.sender);\n        }\n\n        // Ensure the swap order exists and has a sell amount greater than zero\n        require(swap.sellAmount > 0, \"Invalid or nonexistent swap ID\");\n\n        // Ensure that authorize has not been previously called for this swapId\n        if (authorized[swapId].length != 0) {\n            revert AlreadyAuthorized(swapId);\n        }\n        // Set the authorized addresses and amounts for withdrawal\n        unchecked {\n            for (uint i = 0; i < withdraws.length; i++) {\n                authorized[swapId].push(withdraws[i]);\n            }\n        }\n\n        // Emit an event to signal the authorization\n        emit Authorized(swapId);\n        \n    }\n\n    /**\n     * @notice Function to withdraw funds from the swap order\n     * @param secret Secret for the swap\n     * @param swapId Unique identifier for the swap\n     */\n    function withdraw(\n        bytes32 secret,\n        bytes32 swapId\n    ) public {\n        // Retrieve the swap details\n        Order storage swap = orders[swapId];\n\n        bytes32 secretHash = sha256(abi.encodePacked(secret));\n        bytes32 expectedSwapId = keccak256(\n                            abi.encodePacked(\n                                secretHash,\n                                swap.sellAsset,\n                                swap.sellAmount,\n                                swap.swapOwner\n                            )\n                        );\n\n        // Ensure the swap order exists and has a sell amount greater than zero\n        require(swapId == expectedSwapId, \"Invalid secret for withdrawal\");\n\n        //calculate fee amount\n        uint feeAmount = (swap.sellAmount * feePercentage) / 10000;\n\n        uint totalWithdrawalSum = 0;\n        for (uint i = 0; i < authorized[swapId].length; i++) {\n            totalWithdrawalSum += authorized[swapId][i].amount;\n        }\n\n        require(\n            totalWithdrawalSum + feeAmount <= swap.sellAmount,\n            \"Withdrawal amount cannot exceed swap amount\"\n        );\n\n        // Perform asset transfer based on asset type\n        if (swap.sellAsset == address(0x0)) {\n            // Transfer ETH\n            for (uint i = 0; i < authorized[swapId].length; i++) {\n                payable(authorized[swapId][i].addr).transfer(\n                    authorized[swapId][i].amount\n                ); //Transfer funds to LPs\n            }\n            if ((swap.sellAmount - totalWithdrawalSum - feeAmount) > 0)\n                payable(swap.swapOwner).transfer(\n                    swap.sellAmount - totalWithdrawalSum - feeAmount\n                ); //Transfer remaining amount to swapOwner\n            payable(tokenContract.owner()).transfer(feeAmount); //Transfer fees to validator network\n        } else {\n            // Transfer ERC20 tokens from sender to receiver\n            IERC20(swap.sellAsset).transfer(\n                swap.swapOwner,\n                swap.sellAmount - feeAmount\n            );\n            IERC20(swap.sellAsset).transfer(tokenContract.owner(), feeAmount);\n        }\n\n        // Delete the swap order and authorization to prevent re-entrancy\n        delete orders[swapId];\n        delete authorized[swapId];\n\n        // Emit an event to signal the withdrawal\n        emit Withdrawn(swapId, secret);  \n    }\n\n    /**\n     * @notice Function to redeem the swap order when timeout is reached\n     * @param swapId Unique identifier for the swap\n     */\n    function redeem(bytes32 swapId) public {\n        // Ensure the swap exists and is not yet redeemed\n        Order storage swap = orders[swapId];\n        require(swap.sellAmount > 0, \"Invalid or fulfilled swap ID\");\n\n        // Ensure the swap time has expired\n        require(\n            block.timestamp >= swap.swapCreation + 7 days,\n            \"Swap time not yet expired\"\n        );\n\n        //calculate fee amount\n        uint feeAmount = (swap.sellAmount * feePercentage) / 10000;\n\n        // Redeem the swapId\n        if (swap.sellAsset == address(0x0)) {\n            payable(swap.swapOwner).transfer(swap.sellAmount - feeAmount); //Transfer funds to swap owner\n            payable(tokenContract.owner()).transfer(feeAmount); //Transfer fees to validator network\n        } else {\n            // Transfer ERC20 tokens back to owner\n            IERC20(swap.sellAsset).transfer(\n                swap.swapOwner,\n                swap.sellAmount - feeAmount\n            );\n            IERC20(swap.sellAsset).transfer(tokenContract.owner(), feeAmount);\n        }\n\n        // Delete the swap order and authorization to prevent re-entrancy or double redemption\n        delete orders[swapId];\n        delete authorized[swapId];\n\n        emit Redeemed(swapId, swap.swapOwner); // Consider adding an event for successful redemption\n    }\n\n    /**\n     * @notice Function to give the notification to update the fee amount\n     */\n    function updateFeeNotice() public onlyOwner {\n        feeUpdateNotice = block.timestamp + 14 days; // 14 days notice to update fees\n    }\n\n    /**\n     * @notice Function to update the fee amount\n     * @param _newFeePercentage New fee percentage\n    */\n    function updateFeePercentage(uint _newFeePercentage) public onlyOwner {\n        if (block.timestamp <= feeUpdateNotice) {\n            revert NoExpiredFeeUpdateNotice(feeUpdateNotice);\n        }\n        if (_newFeePercentage > 400) {\n            revert OverflowFeeCap(_newFeePercentage); //MaxFee is 4%\n        }\n        feePercentage = _newFeePercentage;\n        emit FeeUpdated(_newFeePercentage);\n    }\n}\n"
    },
    "contracts/interfaces/IDexContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\n/**\n * @title IDexContract\n * @notice Interface for the DexContract contract deployed on the Ethereum network\n \n */\ninterface IDexContract {\n    // Define custom errors\n    error NotOwner(address sender );\n    error OverflowFeeCap(uint amount);\n    error IncorrectETHAmount(uint amount);\n    error PermissionDeniedToAuthorize(address sender);\n    error AlreadyAuthorized(bytes32 swapId);\n    error NoExpiredFeeUpdateNotice(uint);\n\n        /**\n     * @notice Structure to store the swap order details\n     * @param secretHash Hash of the secret for the swap\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     * @param swapOwner Address of the trader initiating the swap\n     * @param swapId Unique identifier for the swap\n     * @param swapCreation Timestamp of swap creation\n     */\n    struct Order {\n        bytes32 secretHash;\n        address sellAsset;\n        uint sellAmount;\n        address swapOwner;\n        bytes32 swapId;\n        uint swapCreation;\n    }\n\n    /**\n     * @notice Structure to store the authorized withdrawal details\n     * @param addr Address authorized for withdrawal\n     * @param amount Amount authorized for withdrawal\n     */\n    struct AuthorizedWithdrawal {\n        address addr;\n        uint amount;\n    }\n\n    /**\n     * Event emitted when the swap order is created\n     * @param secretHash Hash of the secret for the swap\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     * @param swapOwner Address of the trader initiating the swap\n     * @param swapId Unique identifier\n     * @param swapCreation Timestamp of swap creation\n     */\n    event OrderCreated(\n        bytes32 secretHash,\n        address sellAsset,\n        uint sellAmount,\n        address swapOwner,\n        bytes32 swapId,\n        uint swapCreation\n    );\n\n    /**\n     * Event emitted upon authorization of the order\n     * @param swapId Unique identifier for the swap\n     */\n    event Authorized(bytes32 swapId);\n\n    /**\n     * Event emitted upon withdrawal\n     * @param swapId Unique identifier for the swap\n     * @param secret Secret for the swap\n     */\n    event Withdrawn(bytes32 swapId, bytes32 secret);\n\n\n    /**\n     * Event emitted upon redemption\n     * @param swapId Unique identifier for the swap\n     * @param swapOwner Address of the trader initiating the swap\n     */\n    event Redeemed(bytes32 swapId, address swapOwner);\n\n    /**\n     * Event emitted upon fee update\n     * @param newFeePercentage New fee percentage\n    */\n    event FeeUpdated(uint newFeePercentage);\n}\n"
    },
    "contracts/interfaces/IExtendedERC20.sol": {
      "content": "/// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExtendedERC20 is IERC20 {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/ILiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\n/**\n * @title ILiquidityProvider\n * @notice Interface for the LiquidityProvider contract deployed on the Ethereum network\n */\ninterface ILiquidityProvider {\n    // Define custom errors\n    error NotOwner(address sender );\n    error OverflowFeeCap(uint amount);\n    error IncorrectETHAmount(uint amount);\n    error PermissionDeniedToAuthorize(address sender);\n    error AlreadyAuthorized(bytes32 swapId);\n    error NoExpiredFeeUpdateNotice(uint);\n\n        /**\n     * @notice Structure to store the max withdrawal amount by unlock time\n     */\n    struct WithdrawalInfo {\n        uint unlockTime;\n        uint maxWithdrawalAmount;\n    }\n\n        /**\n     * @notice Structure to store the swap order details\n     * @param swapOwner Address of the trader initiating the swap\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     * @param swapCreation Timestamp of swap creation\n     * @param counterParty Address of the other party in trade\n     */\n    struct Order {\n        address swapOwner;\n        address sellAsset;\n        uint sellAmount;\n        uint swapCreation;\n        address counterParty;\n    }\n\n        /**\n     * @notice Event emitted when liquidity is deposited\n     * @param liquidityOwner Address of the liquidity provider\n     * @param depositAsset Address of the asset deposited\n     * @param depositAmount Amount of the asset deposited\n     */\n    event LiquidityDeposited(\n        address indexed liquidityOwner,\n        address indexed depositAsset,\n        uint depositAmount\n    );\n\n        /**\n     * Event emitted when notice to liquidity removal is successfully received\n     * @param liquidityOwner Address of the liquidity provider\n     * @param withdrawalAsset Address of the asset withdrawn\n     * @param withdrawalAmount Amount of the asset withdrawn\n     * @param noticeCompletion Timestamp of notice completion\n     */\n    event LiquidityRemovalNotice(\n        address indexed liquidityOwner,\n        address indexed withdrawalAsset,\n        uint withdrawalAmount,\n        uint noticeCompletion\n    );\n\n    /**\n     * @notice Event emitted when liquidity is removed\n     * @param liquidityOwner Address of the liquidity provider\n     * @param withdrawalAsset Address of the asset withdrawn\n     * @param withdrawalAmount Amount of the asset withdrawn\n        */\n    event LiquidityRemoved(\n        address indexed liquidityOwner,\n        address indexed withdrawalAsset,\n        uint withdrawalAmount\n    );\n\n        /**\n     * Event emitted upon Invoice Creation\n     * @param swapId Identifier for the swap\n     * @param swapOwner Address of the trader initiating the swap\n     * @param counterParty Address of the other party in trade\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     */\n    event InvoiceCreated(\n        bytes32 indexed swapId,\n        address indexed swapOwner,\n        address indexed counterParty,\n        address sellAsset,\n        uint sellAmount\n    );\n\n        /**\n     * Event emitted upon Invoice Settlement\n     * @param swapId Identifier for the swap\n     * @param secret Secret to unlock the swap\n     * @param counterParty Address of the other party in trade\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     */\n    event InvoiceSettled(\n        bytes32 indexed swapId,\n        bytes32 indexed secret,\n        address indexed counterParty,\n        address sellAsset,\n        uint sellAmount\n    );\n}\n"
    },
    "contracts/interfaces/IMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\n/**\n * @title IMultiSigWallet\n * @notice Interface for the MultiSigWallet contract deployed on the Ethereum network\n */\ninterface IMultiSigWallet {\n    function isOwner(address owner) external view returns (bool);\n    function getThreshold() external view returns (uint256);\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/IPortalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IPortalToken\n * @notice Interface for the PORTAL token contract deployed on the Ethereum network.\n */\ninterface IPortalToken is IERC20 {\n    /**\n     * @dev Returns the address of the owner of the PORTAL Token contract. This should be the address of the Portal Foundation.\n     */\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/LiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\nimport \"./interfaces/IPortalToken.sol\";\nimport {ILiquidityProvider} from \"./interfaces/ILiquidityProvider.sol\";\n\n/**\n * @title Liquidity Provider contract\n * @dev Implementation of the Liquidity Provider which manages liquidity management and dispatching funds for the swap\n */\ncontract LiquidityProvider is ILiquidityProvider {\n    /**\n     * @notice Address on the PORTAL Token contract\n     */\n    IPortalToken public tokenContract;\n\n    /**\n     * @notice Stake percentage in basis points (100 basis points = 1%)\n     */\n    uint public stakePercentage;\n\n    /**\n     * @notice Initialize the contract with the PORTAL Token address and stake percentage\n     * @param _tokenAddress Address of the Portal Token contract\n     */\n    constructor(address _tokenAddress) {\n        tokenContract = IPortalToken(_tokenAddress); //Loading the portal contract from portal token address\n        stakePercentage = 300; // Initializing with a 3% stake\n    }\n\n    /**\n     * @notice Modifier to check if the caller is the owner of the token contract\n     */\n    modifier onlyOwner() {\n        if (tokenContract.owner() != msg.sender) {\n            revert NotOwner(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice mapping between liquidity asset, liquidity owner and the liquidity amount\n     */\n    mapping(address => mapping(address => uint)) public liquidities;\n\n    /**\n     * @notice mapping between liquidity asset, liquidity owner and the stake amount\n     */\n    mapping(address => mapping(address => uint)) public stakes;\n\n\n\n    /**\n     * Function to deposit liquidity into the contract\n     * @param depositAsset Address of the asset to be deposited\n     * @param depositAmount Amount of the asset to be deposited\n     */\n    function depositLiquidity(\n        address depositAsset,\n        uint depositAmount,\n        address depositOwner\n    ) public payable {\n        // Handle ETH and ERC20 transfers differently\n        if (depositAsset == address(0x0)) {\n            if (msg.value != depositAmount) {\n                revert IncorrectETHAmount(depositAmount);\n            }\n        } else {\n            // Transfer ERC20 tokens from sender to contract\n            IERC20(depositAsset).transferFrom(\n                msg.sender,\n                address(this),\n                depositAmount\n            );\n        }\n        stakes[depositAsset][depositOwner] +=\n            (depositAmount * stakePercentage) /\n            10000;\n        liquidities[depositAsset][depositOwner] +=\n            depositAmount -\n            (depositAmount * stakePercentage) /\n            10000;\n\n        emit LiquidityDeposited(depositOwner, depositAsset, depositAmount);\n    }\n\n    /**\n     * @notice mapping between penalty asset and the penalty amount\n     */\n    mapping(address => uint) public penalties;\n\n    /**\n     * Function to penalize the user for any misconduct\n     * @param user Address of the user to be penalized\n     * @param penaltyAsset Address of the asset to be penalized\n     * @param penaltyAmount Amount of the asset to be penalized\n     */\n    function lpPenalty(\n        address user,\n        address penaltyAsset,\n        uint penaltyAmount\n    ) public onlyOwner {\n        require(\n            penaltyAmount <= stakes[penaltyAsset][user],\n            \"penalty should be less than stake\"\n        );\n        stakes[penaltyAsset][user] -= penaltyAmount;\n        penalties[penaltyAsset] += penaltyAmount;\n    }\n\n    /**\n     * Function to withdraw penalties\n     * @param withdrawAsset Address of the asset to be withdrawn\n     * @param withdrawAmount Amount of the asset to be withdrawn\n     */\n    function withdrawPenalties(\n        address withdrawAsset,\n        uint withdrawAmount\n    ) public onlyOwner {\n        require(\n            withdrawAmount <= penalties[withdrawAsset],\n            \"withdrawAmount should be less than penalties\"\n        );\n        penalties[withdrawAsset] -= withdrawAmount;\n        if (withdrawAsset == address(0x0)) {\n            // Handle ETH withdrawal\n            payable(msg.sender).transfer(withdrawAmount);\n        } else {\n            // Handle ERC20 token withdrawal\n            IERC20(withdrawAsset).transfer(msg.sender, withdrawAmount);\n        }\n    }\n\n    /**\n     * @notice mapping between liquidity asset, liquidity owner and the withdrawal info\n     */\n    mapping(address => mapping(address => WithdrawalInfo))\n        public liquidityTimelocks;\n\n    /**\n     * Function to remove liquidity from the contract\n     * @param withdrawalAsset Address of the asset to be withdrawn\n     * @param withdrawalAmount Amount of the asset to be withdrawn\n     */\n    function removeLiquidity(\n        address withdrawalAsset,\n        uint withdrawalAmount\n    ) public {\n        require(\n            liquidities[withdrawalAsset][msg.sender] >= withdrawalAmount,\n            \"Insufficient liquidity\"\n        );\n        WithdrawalInfo storage info = liquidityTimelocks[withdrawalAsset][\n            msg.sender\n        ];\n        require(\n            info.unlockTime < block.timestamp,\n            \"Wait till notice completion\"\n        );\n        require(\n            withdrawalAmount <= info.maxWithdrawalAmount,\n            \"Withdrawal amount exceeds limit\"\n        );\n        // Decrement the max withdrawal amount by the amount being withdrawn\n        info.maxWithdrawalAmount -= withdrawalAmount;\n        liquidities[withdrawalAsset][msg.sender] -= withdrawalAmount;\n\n        uint stakeRequired = ((liquidities[withdrawalAsset][msg.sender] +\n            stakes[withdrawalAsset][msg.sender]) * stakePercentage) / 10000;\n\n        uint stakeRefund = 0;\n        if (stakeRequired < stakes[withdrawalAsset][msg.sender]) {\n            stakeRefund = stakes[withdrawalAsset][msg.sender] - stakeRequired;\n            stakes[withdrawalAsset][msg.sender] = stakeRequired;\n        }\n\n        if (withdrawalAsset == address(0x0)) {\n            // Handle ETH withdrawal\n            payable(msg.sender).transfer(withdrawalAmount + stakeRefund);\n        } else {\n            // Handle ERC20 token withdrawal\n            IERC20(withdrawalAsset).transfer(\n                msg.sender,\n                withdrawalAmount + stakeRefund\n            );\n        }\n        emit LiquidityRemoved(\n            msg.sender,\n            withdrawalAsset,\n            withdrawalAmount + stakeRefund\n        );\n    }\n\n    /**\n     * Function to give notice to remove liquidity from the contract\n     * @param withdrawalAsset Address of the asset to be withdrawn\n     * @param maxWithdrawalAmount Maximum amount of the asset to be withdrawn\n     */\n    function removeLiquidityNotice(\n        address withdrawalAsset,\n        uint maxWithdrawalAmount\n    ) public {\n        liquidityTimelocks[withdrawalAsset][msg.sender] = WithdrawalInfo({\n            unlockTime: block.timestamp + 2 days, // 2 days notice to remove liquidity\n            maxWithdrawalAmount: maxWithdrawalAmount\n        });\n\n        emit LiquidityRemovalNotice(\n            msg.sender,\n            withdrawalAsset,\n            maxWithdrawalAmount,\n            block.timestamp + 2 days\n        );\n    }\n\n    /**\n     * @notice mapping between swapId and the swap order details\n     */\n    mapping(bytes32 => Order) public swaps;\n\n    /**\n     * Function to create an invoice for a swap\n     * @param swapId Identifier for the swap\n     * @param sellAsset Asset address to be sold (0x0 for ETH)\n     * @param sellAmount Amount of the asset to be sold\n     * @param counterParty Address of the other party in trade\n     */\n    function createInvoice(\n        bytes32 swapId,\n        address sellAsset,\n        uint sellAmount,\n        address counterParty\n    ) public {\n        require(swaps[swapId].sellAmount == 0, \"swapId already exists\");\n        require(\n            liquidities[sellAsset][msg.sender] >= sellAmount,\n            \"Add more liquidity\"\n        );\n        liquidities[sellAsset][msg.sender] -= sellAmount;\n        swaps[swapId] = Order({\n            swapOwner: msg.sender, // Address of the trader initiating the swap\n            sellAsset: sellAsset, // Asset address to be sold (0x0 for ETH)\n            sellAmount: sellAmount, // Amount of the asset to be sold\n            swapCreation: block.timestamp, // Timestamp of swap creation\n            counterParty: counterParty // Address of the other party in trade\n        });\n        emit InvoiceCreated(\n            swapId,\n            msg.sender,\n            counterParty,\n            swaps[swapId].sellAsset,\n            swaps[swapId].sellAmount\n        );\n    }\n\n    /**\n     * Function to settle an invoice\n     * @param secret Secret to unlock the swap\n     * @param swapId Identifier for the swap\n     */\n    function settleInvoice(bytes32 secret, bytes32 swapId) public {\n        // Ensure the swap order exists and has a sell amount greater than zero\n        require(swaps[swapId].sellAmount > 0, \"Invalid secret for withdrawal\");\n        address payee;\n\n        if (swaps[swapId].swapCreation + 2 days >= block.timestamp) {\n            require(\n                swapId == sha256(abi.encodePacked(secret)),\n                \"swapId must be matched with secret\"\n            );\n            payee = swaps[swapId].counterParty;\n        } else {\n            payee = swaps[swapId].swapOwner;\n        }\n        // transfer the asset to the payee\n        if (swaps[swapId].sellAsset == address(0x0)) {\n            payable(payee).transfer(swaps[swapId].sellAmount);\n        } else {\n            IERC20 erc20 = IERC20(swaps[swapId].sellAsset);\n            erc20.transfer(payee, swaps[swapId].sellAmount);\n        }\n        // Emit an event for successful invoice settlement\n        emit InvoiceSettled(\n            swapId,\n            secret,\n            payee,\n            swaps[swapId].sellAsset,\n            swaps[swapId].sellAmount\n        );\n        delete swaps[swapId];\n    }\n}\n"
    },
    "contracts/Logger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nlibrary Logger {\n    function log(\n      string memory _logType,\n      uint256 value\n    ) public pure returns (string memory) {\n        return string(abi.encodePacked(_logType,\":=>\",Strings.toString(value)));\n    }\n}\n"
    },
    "contracts/mock/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount)  external {\n        return _mint(to, amount);\n    }\n}"
    },
    "contracts/MultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\nimport \"@gnosis.pm/safe-contracts/contracts/Safe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/SafeProxyFactory.sol\";\n\n/**\n * @title MultiSigWallet Contract\n * @dev Implementation of the PMultiSigWallet, which is a multi-sig wallet that requires a threshold of \n * owners to confirm a transaction before it can be executed.\n */\ncontract MultiSigWallet is Safe {}\n"
    },
    "contracts/PortalToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"./interfaces/IPortalToken.sol\";\n\n/**\n * @title PORTAL Token Contract\n * @dev Implementation of the PORTAL token, an ERC20 token with burn and permit capabilities.\n *      The token has a feature for locked tokens and ownership transitions.\n */\ncontract PortalToken is ERC20Burnable, ERC20Permit, IPortalToken {\n    /**\n     * The total initial supply of PORTAL tokens, set to 70 million.\n     */\n    uint256 public constant INITIAL_SUPPLY = 70_000_000 * 1e18;\n\n    /**\n     * The duration of each epoch, set to 30 days.\n     */\n    uint256 public constant EPOCH_DURATION = 30 days;\n\n    /**\n     * The timestamp of the last ownership transition.\n     */\n    uint256 public lastOwnershipTransition;\n\n    /**\n     * The amount that can be minted in each ownership transition.\n     */\n    uint256 public mintableAmount;\n\n    /**\n     * The address of the Portal Foundation.\n     */\n    address public immutable portalFoundation;\n\n    /**\n     * The address of the owner of the contract.\n     */\n    address public owner;\n\n    /**\n     * State for storing information about locked tokens.\n     */\n    struct LockedTokenInfo {\n        uint256 amount;\n        uint256 lockTime;\n    }\n\n    /**\n     * Mapping from user address to their locked token information.\n     */\n    mapping(address => LockedTokenInfo) public lockedTokens;\n\n    /**\n     * Fired when a user locks tokens.\n     * @param user The user whose tokens were locked\n     * @param amount The amount of tokens locked\n     */\n    event TokensLocked(address indexed user, uint256 amount);\n\n    /**\n     * Fired after a user loses the bidding process.\n     * @param user The user whose tokens were unlocked\n     * @param amount The amount of the tokens unlocked\n     */\n    event TokensUnlocked(address indexed user, uint256 amount);\n\n    event TokensBurned(address indexed user, uint256 amount);\n\n    /**\n     * @dev Sets the initial values for the PORTAL token.\n     * @param _portalFoundation Address of the Portal Foundation.\n     */\n    constructor(\n        address _portalFoundation\n    ) ERC20(\"PORTAL\", \"xPORT\") ERC20Permit(\"PORTAL\") {\n        require(\n            _portalFoundation != address(0),\n            \"_portalFoundation address cannot be the zero address\"\n        );\n        portalFoundation = _portalFoundation;\n        _mint(_portalFoundation, INITIAL_SUPPLY); // mint initial supply to portal foundation\n        mintableAmount = INITIAL_SUPPLY / 10; // 10% of the initial supply\n        lastOwnershipTransition = block.timestamp;\n        owner = _portalFoundation; // setting portal foundation as inital owner\n    }\n\n    /**\n     * @dev Transfers ownership with added minting logic. Can only be called by the current owner.\n     * @param _newOwner Address of the new owner.\n     */\n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == owner, \"sender is not the owner\");\n        require(\n            block.timestamp >=\n                lastOwnershipTransition + EPOCH_DURATION - 2 days &&\n                block.timestamp <=\n                lastOwnershipTransition + EPOCH_DURATION + 1 days,\n            \"Transfer period expired\"\n        );\n        _mint(owner, mintableAmount); //mint rewards to current owner\n        mintableAmount -= mintableAmount / 20; // slash mintable rewards for next epoch by 5%\n        owner = _newOwner; // ownership transition\n        lastOwnershipTransition = block.timestamp;\n    }\n\n    /**\n     * @dev Reverts ownership to the Portal Foundation after a specific period.\n     */\n    function revertOwnershipToFoundation() public {\n        require(\n            block.timestamp > lastOwnershipTransition + EPOCH_DURATION + 1 days,\n            \"Ownership revert period not yet expired\"\n        );\n        require(\n            msg.sender == portalFoundation,\n            \"Sender is not portalFoundation\"\n        );\n        _mint(owner, mintableAmount); //mint rewards to current owner\n        mintableAmount -= mintableAmount / 20; // slash mintable rewards for next epoch by 5%\n        owner = portalFoundation; // ownership transition\n        lastOwnershipTransition = block.timestamp;\n    }\n\n    /**\n     * @dev Allows a user to lock a specified amount of their tokens until a specified time.\n     * @param _amount Amount of tokens to be locked.\n     * @param _lockTime Timestamp until which the tokens are locked.\n     */\n    function lockTokens(uint256 _amount, uint256 _lockTime) public {\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n        require(\n            _lockTime >= block.timestamp + 2 * EPOCH_DURATION,\n            \"Lock time must be in the future\"\n        );\n        require(\n            _lockTime >= lockedTokens[msg.sender].lockTime,\n            \"New lockTime must be later than current lockTime\"\n        );\n\n        _transfer(msg.sender, address(this), _amount);\n\n        lockedTokens[msg.sender].amount += _amount;\n        lockedTokens[msg.sender].lockTime = _lockTime;\n\n        emit TokensLocked(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Allows a user or the owner to unlock a specified amount of tokens.\n     * @param _user Address of the user whose tokens are to be unlocked.\n     * @param _amount Amount of tokens to be unlocked.\n     */\n    function unlockTokens(address _user, uint256 _amount) public {\n        require(_amount > 0, \"Amount must be positive\");\n        require(\n            lockedTokens[_user].amount >= _amount,\n            \"Insufficient locked tokens\"\n        );\n        if (msg.sender != owner) {\n            // owner can unlock anytime but not users\n            require(\n                msg.sender == _user &&\n                    block.timestamp > lockedTokens[_user].lockTime,\n                \"Unlocking not allowed in this period\"\n            );\n        }\n        lockedTokens[_user].amount -= _amount;\n\n        _transfer(address(this), _user, _amount);\n\n        emit TokensUnlocked(_user, _amount);\n    }\n\n    function burnLockedTokens(address _user, uint256 _amount) public {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        require(_amount > 0, \"Amount must be positive\");\n        require(\n            lockedTokens[_user].amount >= _amount,\n            \"Insufficient locked tokens\"\n        );\n\n        lockedTokens[_user].amount -= _amount;\n        _burn(address(this), _amount);\n\n        emit TokensBurned(_user, _amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}